---
library(shiny)
library(DECIPHER)
library(Biostrings)
# Define UI for data upload app ----
ui <- fluidPage(
# App title ----
titlePanel("Uploading Files"),
# Sidebar layout with input and output definitions ----
sidebarLayout(
# Sidebar panel for inputs ----
sidebarPanel(
# Input: Select a file ----
fileInput("file1", "Choose a FASTA File",
multiple = FALSE)
# Horizontal line ----
tags$hr(),
# Input: Select separator ----
radioButtons("seqtype", "Sequence type",
choices = c(Nucleotide = "nuc",
Protein = "aa"),
selected = "aa")
# Horizontal line ----
tags$hr(),
# Input: Select number of rows to display ----
# radioButtons("disp", "Display",
#              choices = c(Head = "head",
#                          All = "all"),
#              selected = "head")
),
# Main panel for displaying outputs ----
mainPanel(
# Output: Data file ----
tableOutput("contents")
)
)
)
# Define server logic to read selected file ----
server <- function(input, output) {
output$contents <- renderTable({
# input$file1 will be NULL initially. After the user selects
# and uploads a file, head of that data file by default,
# or all rows if selected, will be shown.
req(input$file1)
# when reading semicolon separated files,
# having a comma separator causes `read.csv` to error
tryCatch(
{
df <- readXStringSet(input$file1$datapath)
},
error = function(e) {
# return a safeError if a parsing error occurs
stop(safeError(e))
}
)
if(input$disp == "head") {
return(head(df))
}
else {
return(df)
}
})
}
# Create Shiny app ----
shinyApp(ui, server)
---
output: html_document
runtime: shiny
---
library(shiny)
library(DECIPHER)
library(Biostrings)
# Define UI for data upload app ----
ui <- fluidPage(
# App title ----
titlePanel("Uploading Files"),
# Sidebar layout with input and output definitions ----
sidebarLayout(
# Sidebar panel for inputs ----
sidebarPanel(
# Input: Select a file ----
fileInput("file1", "Choose a FASTA File",
multiple = FALSE)
# Horizontal line ----
tags$hr(),
# Input: Select separator ----
radioButtons("seqtype", "Sequence type",
choices = c(Nucleotide = "nuc",
Protein = "aa"),
selected = "aa"),
# Horizontal line ----
tags$hr(),
# Input: Select number of rows to display ----
# radioButtons("disp", "Display",
#              choices = c(Head = "head",
#                          All = "all"),
#              selected = "head")
),
# Main panel for displaying outputs ----
mainPanel(
# Output: Data file ----
tableOutput("contents")
)
)
)
# Define server logic to read selected file ----
server <- function(input, output) {
output$contents <- renderTable({
# input$file1 will be NULL initially. After the user selects
# and uploads a file, head of that data file by default,
# or all rows if selected, will be shown.
req(input$file1)
# when reading semicolon separated files,
# having a comma separator causes `read.csv` to error
tryCatch(
{
df <- readXStringSet(input$file1$datapath)
},
error = function(e) {
# return a safeError if a parsing error occurs
stop(safeError(e))
}
)
if(input$disp == "head") {
return(head(df))
}
else {
return(df)
}
})
}
# Create Shiny app ----
shinyApp(ui, server)
---
output: html_document
runtime: shiny
---
library(shiny)
library(DECIPHER)
library(Biostrings)
# Define UI for data upload app ----
ui <- fluidPage(
# App title ----
titlePanel("Uploading Files"),
# Sidebar layout with input and output definitions ----
sidebarLayout(
# Sidebar panel for inputs ----
sidebarPanel(
# Input: Select a file ----
fileInput("file1", "Choose a FASTA File",
multiple = FALSE)
# Horizontal line ----
tags$hr(),
# Input: Select separator ----
radioButtons("seqtype", "Sequence type",
choices = c(Nucleotide = "nuc",
Protein = "aa"),
selected = "aa"),
# Horizontal line ----
tags$hr(),
# Input: Select number of rows to display ----
radioButtons("disp", "Display",
choices = c(Head = "head",
All = "all"),
selected = "head")
),
# Main panel for displaying outputs ----
mainPanel(
# Output: Data file ----
tableOutput("contents")
)
)
)
# Define server logic to read selected file ----
server <- function(input, output) {
output$contents <- renderTable({
# input$file1 will be NULL initially. After the user selects
# and uploads a file, head of that data file by default,
# or all rows if selected, will be shown.
req(input$file1)
# when reading semicolon separated files,
# having a comma separator causes `read.csv` to error
tryCatch(
{
df <- readXStringSet(input$file1$datapath)
},
error = function(e) {
# return a safeError if a parsing error occurs
stop(safeError(e))
}
)
if(input$disp == "head") {
return(head(df))
}
else {
return(df)
}
})
}
# Create Shiny app ----
shinyApp(ui, server)
---
output: html_document
runtime: shiny
---
library(shiny)
library(DECIPHER)
library(Biostrings)
# Define UI for data upload app ----
ui <- fluidPage(
# App title ----
titlePanel("Uploading Files"),
# Sidebar layout with input and output definitions ----
sidebarLayout(
# Sidebar panel for inputs ----
sidebarPanel(
# Input: Select a file ----
fileInput("file1", "Choose a FASTA File",
multiple = FALSE),
# Horizontal line ----
tags$hr(),
# Input: Select separator ----
radioButtons("seqtype", "Sequence type",
choices = c(Nucleotide = "nuc",
Protein = "aa"),
selected = "aa"),
# Horizontal line ----
tags$hr(),
# Input: Select number of rows to display ----
radioButtons("disp", "Display",
choices = c(Head = "head",
All = "all"),
selected = "head")
),
# Main panel for displaying outputs ----
mainPanel(
# Output: Data file ----
tableOutput("contents")
)
)
)
# Define server logic to read selected file ----
server <- function(input, output) {
output$contents <- renderTable({
# input$file1 will be NULL initially. After the user selects
# and uploads a file, head of that data file by default,
# or all rows if selected, will be shown.
req(input$file1)
# when reading semicolon separated files,
# having a comma separator causes `read.csv` to error
tryCatch(
{
df <- readXStringSet(input$file1$datapath)
},
error = function(e) {
# return a safeError if a parsing error occurs
stop(safeError(e))
}
)
if(input$disp == "head") {
return(head(df))
}
else {
return(df)
}
})
}
# Create Shiny app ----
shinyApp(ui, server)
---
output: html_document
runtime: shiny
---
library(shiny)
library(DECIPHER)
library(Biostrings)
# Define UI for data upload app ----
ui <- fluidPage(
# App title ----
titlePanel("Uploading Files"),
# Sidebar layout with input and output definitions ----
sidebarLayout(
# Sidebar panel for inputs ----
sidebarPanel(
# Input: Select a file ----
fileInput("file1", "Choose a FASTA File",
multiple = FALSE),
# Horizontal line ----
tags$hr(),
# Input: Select separator ----
radioButtons("seqtype", "Sequence type",
choices = c(Nucleotide = "nuc",
Protein = "aa"),
selected = "aa")
),
# Main panel for displaying outputs ----
mainPanel(
# Output: Data file ----
tableOutput("contents")
)
)
)
# Define server logic to read selected file ----
server <- function(input, output) {
output$contents <- renderTable({
# input$file1 will be NULL initially. After the user selects
# and uploads a file, head of that data file by default,
# or all rows if selected, will be shown.
req(input$file1)
# when reading semicolon separated files,
# having a comma separator causes `read.csv` to error
tryCatch(
{
if(input$seqtype == "aa") {
return(readAAStringSet(input$file1$datapath))
}
else {
return(readDNAStringSet(input$file1$datapath))
}
})
},
error = function(e) {
# return a safeError if a parsing error occurs
stop(safeError(e))
}
)
}
# Create Shiny app ----
shinyApp(ui, server)
(500 * 5)
(750 * 5)
3750 - 2500
1250 - 375
3228/5
3220/5
setwd("~/Documents/Wageningen_UR/github/mibig_training_set_build_test/")
knitr::opts_chunk$set(echo = TRUE, root.dir = "~/Documents/Wageningen_UR/github/mibig_training_set_build_test/")
pacman::p_load("caret", "Biostrings", "phangorn", "ape", "seqinr", "DECIPHER", "cowplot", "tidymodels", "ranger", "tree", "rsample", "tidyverse", "randomForest","gbm","nnet","e1071","svmpath","lars","glmnet","svmpath")
# Read in the data
rawdat <- read_csv("data/1742_seqs_510_feats_for_supervised_20190204.csv")
# Read in the data
rawdat <- read_csv("data/1742_seqs_510_feats_for_supervised_20190104.csv")
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = "~/Documents/Wageningen_UR/github/mibig_training_set_build_test/")
pacman::p_load("caret", "Biostrings", "phangorn", "ape", "seqinr", "DECIPHER", "cowplot", "tidymodels", "ranger", "tree", "rsample", "tidyverse", "randomForest","gbm","nnet","e1071","svmpath","lars","glmnet","svmpath")
rf_pred <- predict(rf, newdata = form_test)
# Read in the RF model
rf <- readRDS("data/model_comparisons/rf_small_subst_group_20190204.rds")
# Confusion matrix
getTrainPerf(rf)
rf_pred <- predict(rf, data = form_test)
# Read in the data
rawdat <- read_csv("data/1742_seqs_510_feats_for_supervised_20190104.csv")
# Read in the RF model
rf <- readRDS("data/model_comparisons/rf_small_subst_group_20190204.rds")
rf$predictions
rf_pred <- predict(rf, newdata = form_test)
134/2
935/8
1453/8
# Install packages
pacman::p_load("data.table", "plotKML", "scales", "tidyverse", "stringr", "Biostrings","DECIPHER","igraph","RColorBrewer", "officer", "rvg")
# Set working directory
setwd("~/Documents/Wageningen_UR/github/mibig_training_set_build_test/")
# Read in the Python predictions
pypred <- readAAStringSet("data/parsed_BGC_sequences_combined_27052019_predictions.txt")
# Read in the Python predictions
pypred <- read_delim("data/parsed_BGC_sequences_combined_27052019_predictions.txt")
# Install packages
pacman::p_load("data.table", "tidyverse", "plotKML", "scales", "tidyverse", "stringr", "Biostrings","DECIPHER","igraph","RColorBrewer", "officer", "rvg")
# Read in the Python predictions
pypred <- read_delim("data/parsed_BGC_sequences_combined_27052019_predictions.txt")
# Read in the Python predictions
pypred <- fread("data/parsed_BGC_sequences_combined_27052019_predictions.txt")
# Read in the Python predictions
pypred <- fread("data/parsed_BGC_sequences_combined_27052019_predictions.txt", data.table = F)
head(pypred)
# Read in the R predictions
rpred <- read_csv("data/AdenylPred-2019-05-27.csv")
head(rpred)
# Read in the R predictions
rpred <- read_csv("data/AdenylPred-2019-05-27.csv") %>%
janitor::clean_names()
head(rpred)
head(pypred)
head(rpred)
# Read in the Python predictions
pypred <- fread("data/parsed_BGC_sequences_combined_27052019_predictions.txt", data.table = F) %>%
janitor::clean_names()
# Read in the R predictions
rpred <- read_csv("data/AdenylPred-2019-05-27.csv") %>%
janitor::clean_names()
head(rpred)
# Join the two predictions
comb_pred <- rpred %>%
inner_join(., pypred, by = "query_join")
# Join the two predictions
comb_pred <- rpred %>%
inner_join(., pypred, by = "query_name")
head(comb_pred)
nchar(pypred$)
nchar(pypred$query_name)
nchar(rpred$query_name)
pypred$query_name
rpred$query_name
intersect(pypred$query_name, rpred$query_name)
pypred$query_name
head(pypred$query_name)
head(rpred$query_name)
tail(rpred$query_name)
intersect(pypred$query_name, rpred$query_name)
class(rpred$query_name)
class(pypred$query_name)
tail(rpred$query_name)
head(rpred$query_name)
head(pypred$query_name)
tail(pypred$query_name)
rpred$query_name[grep("arthrofactin", rpred$query_name)]
pypred$query_name[grep("arthrofactin", pypred$query_name)]
# Read in the Python predictions
pypred <- fread("data/parsed_BGC_sequences_combined_27052019_predictions.txt", data.table = F) %>%
janitor::clean_names() %>%
mutate(nam_trimmed = substr(query_name, 1, (nchar(query_name) - 5)))
pypred$nam_trimmed
intersect(pypred$query_name, rpred$query_name)
pypred$nam_trimmed
grep("arthrofactin", pypred$nam)
pypred$nam_trimmed[grep("arthrofactin", pypred$nam_trimmed)]
rpred$query_name[grep("arthrofactin", rpred$query_name)]
intersect(rpred$query_name, pypred$nam_trimmed)
# Read in the Python predictions
colnames(pypred)
# Read in the Python predictions
colnames(pypred)
pypred <- fread("data/parsed_BGC_sequences_combined_27052019_predictions.txt", data.table = F) %>%
janitor::clean_names() %>%
mutate(nam_trimmed = substr(query_name, 1, (nchar(query_name) - 5))) %>%
dplyr::select(nam_trimmed, prediction, probability_score) %>%
dplyr::rename(query_name = nam_trimmed)
# Read in the R predictions
rpred <- read_csv("data/AdenylPred-2019-05-27.csv") %>%
janitor::clean_names()
# Join the two predictions
comb_pred <- rpred %>%
inner_join(., pypred, by = "query_name")
head(comb_pred)
pypred <- fread("data/parsed_BGC_sequences_combined_27052019_predictions.txt", data.table = F) %>%
janitor::clean_names() %>%
mutate(nam_trimmed = substr(query_name, 1, (nchar(query_name) - 5))) %>%
dplyr::select(nam_trimmed, prediction, probability_score) %>%
dplyr::rename(query_name = nam_trimmed,
py_prediction = prediction,
py_probability_score = probability_score)
# Read in the R predictions
rpred <- read_csv("data/AdenylPred-2019-05-27.csv") %>%
janitor::clean_names()
# Join the two predictions
comb_pred <- rpred %>%
inner_join(., pypred, by = "query_name")
head(comb_pred)
# See which agree
which(comb_pred$py_prediction == comb_pred$predicted_substrate_specificity_ss)
# See which agree
comb_pred[comb_pred$py_prediction == comb_pred$predicted_substrate_specificity_ss,]
comb_pred$py_prediction
comb_pred$predicted_substrate_specificity_ss
# Read in the Python predictions
colnames(pypred)
pypred <- fread("data/parsed_BGC_sequences_combined_27052019_predictions.txt", data.table = F) %>%
janitor::clean_names() %>%
mutate(nam_trimmed = substr(query_name, 1, (nchar(query_name) - 5))) %>%
dplyr::select(nam_trimmed, prediction, probability_score) %>%
dplyr::rename(query_name = nam_trimmed,
py_prediction = prediction,
py_probability_score = probability_score)
pypred$py_prediction <- gsub("\\.", " ", pypred$py_prediction)
# Read in the R predictions
rpred <- read_csv("data/AdenylPred-2019-05-27.csv") %>%
janitor::clean_names()
# Join the two predictions
comb_pred <- rpred %>%
inner_join(., pypred, by = "query_name")
head(comb_pred)
# See which agree
comb_pred[comb_pred$py_prediction == comb_pred$predicted_substrate_specificity_ss,]
# See which agree
agree_pred <- comb_pred[comb_pred$py_prediction == comb_pred$predicted_substrate_specificity_ss,]
write_csv(comb_pred, "output/combined_py_and_r_predictions.csv")
pypred$py_prediction <- gsub(" aa", "", pypred$py_prediction)
# Read in the R predictions
rpred <- read_csv("data/AdenylPred-2019-05-27.csv") %>%
janitor::clean_names()
# Join the two predictions
comb_pred <- rpred %>%
inner_join(., pypred, by = "query_name")
head(comb_pred)
write_csv(comb_pred, "output/combined_py_and_r_predictions.csv")
# See which agree
agree_pred <- comb_pred[comb_pred$py_prediction == comb_pred$predicted_substrate_specificity_ss,]
dont_agree <- comb_pred[comb_pred$py_prediction != comb_pred$predicted_substrate_specificity_ss,]
dont_agree
write_csv(dont_agree, "output/dont_agree_combined_py_and_r_predictions.csv")
rpred$predicted_substrate_specificity_ss <- tolower(rpred$predicted_substrate_specificity_ss)
# Join the two predictions
comb_pred <- rpred %>%
inner_join(., pypred, by = "query_name")
head(comb_pred)
write_csv(comb_pred, "output/combined_py_and_r_predictions.csv")
# See which agree
agree_pred <- comb_pred[comb_pred$py_prediction == comb_pred$predicted_substrate_specificity_ss,] # most agree
dont_agree <- comb_pred[comb_pred$py_prediction != comb_pred$predicted_substrate_specificity_ss,]
write_csv(dont_agree, "output/dont_agree_combined_py_and_r_predictions.csv")
